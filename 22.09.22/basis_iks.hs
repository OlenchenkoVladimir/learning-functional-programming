--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--  Модуль IKS - описание функции для трансформации лямбда-выражения в базис  --
--  IKS.                                                                      --
--                                                                            --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
module Basis_IKS
  (Lambda(..), i, k, s, b, c, w, y, free, transform)
where

--------------------------------------------------------------------------------
-- Тип для представления лямбда-терма. Лямбда-терм представляет собой переменную
-- (конструктор Var), у которой задано её имя в строковом виде; приложение двух
-- лямбда-термов друг к другу (конструктор App); а также лямбда-абстракцию
-- (конструктор Lam), в которой переменная связана с лямбда-термом. Переменная в
-- абстракции также задаётся по строковому имени.

data Lambda = Var String        -- Переменная
            | App Lambda Lambda -- Приложение (аппликация)
            | Lam String Lambda -- Абстракция
  deriving Eq

--------------------------------------------------------------------------------
-- Реализация типа Lambda для класса Show для более интересного представления
-- лямбда-термов в виде строк. В качестве символа "лямбда" используется знак
-- "\".
--
-- * Переменная представляется её именем.
-- * Аппликация представляется в виде двух лямбда-термов, заключённых в скобки
-- (или без скобок, если лямбда-термы простые). При этом абстракции, участвующие
-- в аппликации, также заключаются в скобки.
-- * Абстракция представляется в виде "\x.TERM", где x - имя переменной.

instance Show Lambda where
  show (Var x)   = x
  show (App x y) = case y of App _ _ -> showLam x ++ "(" ++ show y ++ ")"
                             _       -> showLam x ++ showLam y
    where showLam l@(Lam _ _) = "(" ++  show l  ++ ")"
          showLam x           = show x
  show (Lam x e)  = "\\" ++ x ++ "." ++ show e

--------------------------------------------------------------------------------
-- Константные функции для представления базовых комбинаторов I, K, S.

i = Var "I"
k = Var "K"
s = Var "S"

--------------------------------------------------------------------------------
-- Предикат для проверки того, является ли заданная переменная свободной в
-- некотором лямбда-терме.
--
-- Входные параметры:
--   x - переменная, чью свободность необходимо проверить.
--   l - лямбда-терм, в котором проверяется свободность переменной x.
--
-- Возвращаемое значение:
--   True, если переменная x свободна в лямбда-терме l.
--   False в противном случае.

free :: [Char] -> Lambda -> Bool
free x (Var y)     = x == y
free x (App e1 e2) = free x e1 || free x e2
free x (Lam y e)   = free x e

--------------------------------------------------------------------------------

transform :: Lambda -> Lambda
transform (Var x)                                = Var x
transform (App x y)                              = App (transform x)
                                                       (transform y)
transform (Lam x (Var y))     | x == y           = i
transform (Lam x e)           | (not . free x) e = App k (transform e)
transform (Lam x l@(Lam y e)) | free x e         = transform (Lam x (transform l))
transform (Lam x (App e1 e2))                    = App (App s (transform (Lam x e1)))
                                                       (transform (Lam x e2))

b = Lam "x" (Lam "y" (Lam "z" (App (Var "x") (App (Var "y") (Var "z")))))
c = Lam "x" (Lam "y" (Lam "z" (App (App (Var "x") (Var "z")) (Var "y"))))
w = Lam "x" (Lam "y" (App (App (Var "x") (Var "y")) (Var "y")))

y a = App a (y a)

--[ КОНЕЦ МОДУЛЯ ]--------------------------------------------------------------
-- transform b 
-- S(S(KS)(S(KK)(S(KS)(S(KK)I))))(K(S(S(KS)(S(KK)I))(KI)))
fac = (\f -> \n -> if n == 0 then 1 else (*) n (f (pred n)) ) fac
fac' n = if n == 0 then 1 else n * fac' (n - 1 )  
